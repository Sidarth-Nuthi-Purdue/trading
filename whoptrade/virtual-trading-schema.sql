-- VIRTUAL TRADING ACCOUNTS SCHEMA
-- This script creates the tables and functions needed for virtual trading accounts
-- where users trade on a single master Alpaca account

-- =============================================
-- PART 1: TABLE DEFINITIONS
-- =============================================

-- Virtual trading accounts for users
CREATE TABLE IF NOT EXISTS public.virtual_trading_accounts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  initial_balance DECIMAL(20, 2) NOT NULL DEFAULT 10000.00,  -- Default $10,000 starting balance
  current_balance DECIMAL(20, 2) NOT NULL DEFAULT 10000.00,  -- Current cash balance
  total_deposited DECIMAL(20, 2) NOT NULL DEFAULT 10000.00,  -- Total money deposited
  total_withdrawn DECIMAL(20, 2) NOT NULL DEFAULT 0.00,      -- Total money withdrawn
  status VARCHAR(50) NOT NULL DEFAULT 'ACTIVE',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT unique_user_account UNIQUE (user_id)
);

-- Virtual positions table to track user positions
CREATE TABLE IF NOT EXISTS public.virtual_positions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  account_id BIGINT NOT NULL REFERENCES public.virtual_trading_accounts(id) ON DELETE CASCADE,
  symbol VARCHAR(20) NOT NULL,
  qty DECIMAL(20, 6) NOT NULL,
  avg_entry_price DECIMAL(20, 6) NOT NULL,
  current_price DECIMAL(20, 6),
  market_value DECIMAL(20, 2),
  cost_basis DECIMAL(20, 2) NOT NULL,
  unrealized_pl DECIMAL(20, 2),
  unrealized_plpc DECIMAL(20, 6),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT unique_user_symbol UNIQUE (user_id, symbol)
);

-- Virtual orders table to track user orders
CREATE TABLE IF NOT EXISTS public.virtual_orders (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  account_id BIGINT NOT NULL REFERENCES public.virtual_trading_accounts(id) ON DELETE CASCADE,
  alpaca_order_id VARCHAR(255),  -- ID of the order in Alpaca (if executed)
  client_order_id VARCHAR(255),  -- Client-generated order ID
  symbol VARCHAR(20) NOT NULL,
  qty DECIMAL(20, 6) NOT NULL,
  side VARCHAR(10) NOT NULL CHECK (side IN ('buy', 'sell')),
  type VARCHAR(20) NOT NULL CHECK (type IN ('market', 'limit', 'stop', 'stop_limit', 'trailing_stop')),
  time_in_force VARCHAR(10) NOT NULL CHECK (time_in_force IN ('day', 'gtc', 'opg', 'cls', 'ioc', 'fok')),
  limit_price DECIMAL(20, 6),
  stop_price DECIMAL(20, 6),
  status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'open', 'filled', 'canceled', 'expired', 'rejected')),
  filled_qty DECIMAL(20, 6) DEFAULT 0,
  filled_avg_price DECIMAL(20, 6),
  filled_at TIMESTAMPTZ,
  canceled_at TIMESTAMPTZ,
  expired_at TIMESTAMPTZ,
  rejected_at TIMESTAMPTZ,
  rejection_reason TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Virtual transactions table to track deposits, withdrawals, buys, sells
CREATE TABLE IF NOT EXISTS public.virtual_transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  account_id BIGINT NOT NULL REFERENCES public.virtual_trading_accounts(id) ON DELETE CASCADE,
  order_id BIGINT REFERENCES public.virtual_orders(id),
  type VARCHAR(20) NOT NULL CHECK (type IN ('deposit', 'withdrawal', 'buy', 'sell')),
  symbol VARCHAR(20),  -- Null for deposits/withdrawals
  qty DECIMAL(20, 6),  -- Null for deposits/withdrawals
  price DECIMAL(20, 6), -- Null for deposits/withdrawals
  amount DECIMAL(20, 2) NOT NULL,  -- Positive for deposits/buys, negative for withdrawals/sells
  description TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =============================================
-- PART 2: SECURITY POLICIES (RLS)
-- =============================================

-- Enable Row Level Security
ALTER TABLE public.virtual_trading_accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.virtual_positions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.virtual_orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.virtual_transactions ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only view their own accounts/data
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE policyname = 'Users can view own virtual accounts' AND tablename = 'virtual_trading_accounts'
  ) THEN
    CREATE POLICY "Users can view own virtual accounts" 
    ON public.virtual_trading_accounts FOR SELECT 
    USING (auth.uid() = user_id);
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE policyname = 'Users can view own virtual positions' AND tablename = 'virtual_positions'
  ) THEN
    CREATE POLICY "Users can view own virtual positions" 
    ON public.virtual_positions FOR SELECT 
    USING (auth.uid() = user_id);
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE policyname = 'Users can view own virtual orders' AND tablename = 'virtual_orders'
  ) THEN
    CREATE POLICY "Users can view own virtual orders" 
    ON public.virtual_orders FOR SELECT 
    USING (auth.uid() = user_id);
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE policyname = 'Users can view own virtual transactions' AND tablename = 'virtual_transactions'
  ) THEN
    CREATE POLICY "Users can view own virtual transactions" 
    ON public.virtual_transactions FOR SELECT 
    USING (auth.uid() = user_id);
  END IF;
END $$;

-- Policy: Only service role can insert/update/delete
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE policyname = 'Service role can manage all virtual accounts' AND tablename = 'virtual_trading_accounts'
  ) THEN
    CREATE POLICY "Service role can manage all virtual accounts" 
    ON public.virtual_trading_accounts FOR ALL 
    TO service_role 
    USING (true) 
    WITH CHECK (true);
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE policyname = 'Service role can manage all virtual positions' AND tablename = 'virtual_positions'
  ) THEN
    CREATE POLICY "Service role can manage all virtual positions" 
    ON public.virtual_positions FOR ALL 
    TO service_role 
    USING (true) 
    WITH CHECK (true);
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE policyname = 'Service role can manage all virtual orders' AND tablename = 'virtual_orders'
  ) THEN
    CREATE POLICY "Service role can manage all virtual orders" 
    ON public.virtual_orders FOR ALL 
    TO service_role 
    USING (true) 
    WITH CHECK (true);
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE policyname = 'Service role can manage all virtual transactions' AND tablename = 'virtual_transactions'
  ) THEN
    CREATE POLICY "Service role can manage all virtual transactions" 
    ON public.virtual_transactions FOR ALL 
    TO service_role 
    USING (true) 
    WITH CHECK (true);
  END IF;
END $$;

-- =============================================
-- PART 3: FUNCTIONS FOR VIRTUAL TRADING
-- =============================================

-- Function to create or get a virtual trading account for a user
CREATE OR REPLACE FUNCTION get_or_create_virtual_account(
  p_user_id UUID,
  p_initial_balance DECIMAL DEFAULT 10000.00
) 
RETURNS TABLE(
  id BIGINT,
  user_id UUID,
  initial_balance DECIMAL,
  current_balance DECIMAL,
  total_deposited DECIMAL,
  total_withdrawn DECIMAL,
  status VARCHAR,
  created_at TIMESTAMPTZ
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_account_id BIGINT;
  v_created BOOLEAN := FALSE;
BEGIN
  -- Check if user already has an account
  SELECT id INTO v_account_id 
  FROM public.virtual_trading_accounts 
  WHERE user_id = p_user_id;
  
  -- If no account exists, create one
  IF v_account_id IS NULL THEN
    INSERT INTO public.virtual_trading_accounts 
      (user_id, initial_balance, current_balance, total_deposited)
    VALUES 
      (p_user_id, p_initial_balance, p_initial_balance, p_initial_balance)
    RETURNING id INTO v_account_id;
    
    -- Record the initial deposit transaction
    INSERT INTO public.virtual_transactions
      (user_id, account_id, type, amount, description)
    VALUES
      (p_user_id, v_account_id, 'deposit', p_initial_balance, 'Initial account funding');
      
    v_created := TRUE;
  END IF;
  
  -- Return the account details
  RETURN QUERY
  SELECT 
    vta.id,
    vta.user_id,
    vta.initial_balance,
    vta.current_balance,
    vta.total_deposited,
    vta.total_withdrawn,
    vta.status,
    vta.created_at
  FROM public.virtual_trading_accounts vta
  WHERE vta.id = v_account_id;
END;
$$;

-- Function to place a virtual order
CREATE OR REPLACE FUNCTION place_virtual_order(
  p_user_id UUID,
  p_symbol VARCHAR,
  p_qty DECIMAL,
  p_side VARCHAR,
  p_type VARCHAR,
  p_time_in_force VARCHAR,
  p_limit_price DECIMAL DEFAULT NULL,
  p_stop_price DECIMAL DEFAULT NULL,
  p_client_order_id VARCHAR DEFAULT NULL
) 
RETURNS TABLE(
  id BIGINT,
  user_id UUID,
  account_id BIGINT,
  client_order_id VARCHAR,
  symbol VARCHAR,
  qty DECIMAL,
  side VARCHAR,
  type VARCHAR,
  time_in_force VARCHAR,
  limit_price DECIMAL,
  stop_price DECIMAL,
  status VARCHAR,
  created_at TIMESTAMPTZ
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_account_id BIGINT;
  v_current_balance DECIMAL;
  v_order_id BIGINT;
  v_current_price DECIMAL;
  v_estimated_cost DECIMAL;
  v_client_order_id VARCHAR;
BEGIN
  -- Generate a client order ID if not provided
  IF p_client_order_id IS NULL THEN
    v_client_order_id := 'virtual-' || REPLACE(gen_random_uuid()::TEXT, '-', '');
  ELSE
    v_client_order_id := p_client_order_id;
  END IF;

  -- Get the user's account
  SELECT id, current_balance INTO v_account_id, v_current_balance
  FROM public.virtual_trading_accounts
  WHERE user_id = p_user_id;
  
  IF v_account_id IS NULL THEN
    RAISE EXCEPTION 'User does not have a virtual trading account';
  END IF;
  
  -- For buy orders, check if the user has enough balance
  -- Note: In a real implementation, you would get the current price from a market data service
  -- For simplicity, we'll use the limit price as the estimated price for market orders
  IF p_side = 'buy' THEN
    -- Estimate the cost of the order
    v_current_price := COALESCE(p_limit_price, p_stop_price, 0);
    v_estimated_cost := p_qty * v_current_price;
    
    -- Check if the user has enough balance
    IF v_current_price > 0 AND v_estimated_cost > v_current_balance THEN
      RAISE EXCEPTION 'Insufficient funds for order. Needed: %, Available: %', v_estimated_cost, v_current_balance;
    END IF;
  END IF;
  
  -- Create the order
  INSERT INTO public.virtual_orders
    (user_id, account_id, client_order_id, symbol, qty, side, type, time_in_force, limit_price, stop_price, status)
  VALUES
    (p_user_id, v_account_id, v_client_order_id, p_symbol, p_qty, p_side, p_type, p_time_in_force, p_limit_price, p_stop_price, 'pending')
  RETURNING id INTO v_order_id;
  
  -- Return the order details
  RETURN QUERY
  SELECT 
    vo.id,
    vo.user_id,
    vo.account_id,
    vo.client_order_id,
    vo.symbol,
    vo.qty,
    vo.side,
    vo.type,
    vo.time_in_force,
    vo.limit_price,
    vo.stop_price,
    vo.status,
    vo.created_at
  FROM public.virtual_orders vo
  WHERE vo.id = v_order_id;
END;
$$;

-- Function to execute a virtual order (simulate a fill)
CREATE OR REPLACE FUNCTION execute_virtual_order(
  p_order_id BIGINT,
  p_filled_price DECIMAL,
  p_filled_qty DECIMAL DEFAULT NULL
) 
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_order RECORD;
  v_filled_qty DECIMAL;
  v_cost DECIMAL;
  v_position_exists BOOLEAN;
  v_current_qty DECIMAL;
  v_current_avg_price DECIMAL;
  v_current_cost_basis DECIMAL;
BEGIN
  -- Get the order details
  SELECT 
    vo.id, 
    vo.user_id, 
    vo.account_id, 
    vo.symbol, 
    vo.qty, 
    vo.side, 
    vo.status
  INTO v_order
  FROM public.virtual_orders vo
  WHERE vo.id = p_order_id;
  
  IF v_order IS NULL THEN
    RAISE EXCEPTION 'Order not found';
  END IF;
  
  IF v_order.status != 'pending' AND v_order.status != 'open' THEN
    RAISE EXCEPTION 'Order is not in a state that can be executed';
  END IF;
  
  -- Determine the filled quantity
  v_filled_qty := COALESCE(p_filled_qty, v_order.qty);
  
  -- Calculate the cost of the order
  v_cost := v_filled_qty * p_filled_price;
  
  -- Update the order
  UPDATE public.virtual_orders
  SET 
    status = 'filled',
    filled_qty = v_filled_qty,
    filled_avg_price = p_filled_price,
    filled_at = NOW()
  WHERE id = p_order_id;
  
  -- Update the account balance
  IF v_order.side = 'buy' THEN
    -- Reduce the account balance
    UPDATE public.virtual_trading_accounts
    SET current_balance = current_balance - v_cost
    WHERE id = v_order.account_id;
    
    -- Record the transaction
    INSERT INTO public.virtual_transactions
      (user_id, account_id, order_id, type, symbol, qty, price, amount, description)
    VALUES
      (v_order.user_id, v_order.account_id, p_order_id, 'buy', v_order.symbol, v_filled_qty, p_filled_price, -v_cost, 
       'Bought ' || v_filled_qty || ' shares of ' || v_order.symbol || ' at $' || p_filled_price);
  ELSE -- 'sell'
    -- Increase the account balance
    UPDATE public.virtual_trading_accounts
    SET current_balance = current_balance + v_cost
    WHERE id = v_order.account_id;
    
    -- Record the transaction
    INSERT INTO public.virtual_transactions
      (user_id, account_id, order_id, type, symbol, qty, price, amount, description)
    VALUES
      (v_order.user_id, v_order.account_id, p_order_id, 'sell', v_order.symbol, v_filled_qty, p_filled_price, v_cost,
       'Sold ' || v_filled_qty || ' shares of ' || v_order.symbol || ' at $' || p_filled_price);
  END IF;
  
  -- Check if the user already has a position in this symbol
  SELECT EXISTS (
    SELECT 1 FROM public.virtual_positions
    WHERE user_id = v_order.user_id AND symbol = v_order.symbol
  ) INTO v_position_exists;
  
  -- Update or create the position
  IF v_position_exists THEN
    -- Get the current position details
    SELECT qty, avg_entry_price, cost_basis
    INTO v_current_qty, v_current_avg_price, v_current_cost_basis
    FROM public.virtual_positions
    WHERE user_id = v_order.user_id AND symbol = v_order.symbol;
    
    IF v_order.side = 'buy' THEN
      -- Update the position with the new shares
      UPDATE public.virtual_positions
      SET 
        qty = qty + v_filled_qty,
        avg_entry_price = (v_current_cost_basis + v_cost) / (v_current_qty + v_filled_qty),
        cost_basis = v_current_cost_basis + v_cost,
        current_price = p_filled_price,
        market_value = (v_current_qty + v_filled_qty) * p_filled_price,
        updated_at = NOW()
      WHERE user_id = v_order.user_id AND symbol = v_order.symbol;
    ELSE -- 'sell'
      -- Reduce the position
      IF v_current_qty <= v_filled_qty THEN
        -- If selling all or more than owned, delete the position
        DELETE FROM public.virtual_positions
        WHERE user_id = v_order.user_id AND symbol = v_order.symbol;
      ELSE
        -- Reduce the position
        UPDATE public.virtual_positions
        SET 
          qty = qty - v_filled_qty,
          cost_basis = v_current_cost_basis * (1 - (v_filled_qty / v_current_qty)),
          current_price = p_filled_price,
          market_value = (v_current_qty - v_filled_qty) * p_filled_price,
          updated_at = NOW()
        WHERE user_id = v_order.user_id AND symbol = v_order.symbol;
      END IF;
    END IF;
  ELSIF v_order.side = 'buy' THEN
    -- Create a new position
    INSERT INTO public.virtual_positions
      (user_id, account_id, symbol, qty, avg_entry_price, current_price, market_value, cost_basis)
    VALUES
      (v_order.user_id, v_order.account_id, v_order.symbol, v_filled_qty, p_filled_price, p_filled_price, v_cost, v_cost);
  END IF;
  
  RETURN TRUE;
END;
$$;

-- Function to cancel a virtual order
CREATE OR REPLACE FUNCTION cancel_virtual_order(
  p_order_id BIGINT
) 
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_order RECORD;
BEGIN
  -- Get the order details
  SELECT id, status
  INTO v_order
  FROM public.virtual_orders
  WHERE id = p_order_id;
  
  IF v_order IS NULL THEN
    RAISE EXCEPTION 'Order not found';
  END IF;
  
  IF v_order.status != 'pending' AND v_order.status != 'open' THEN
    RAISE EXCEPTION 'Order is not in a state that can be canceled';
  END IF;
  
  -- Update the order
  UPDATE public.virtual_orders
  SET 
    status = 'canceled',
    canceled_at = NOW()
  WHERE id = p_order_id;
  
  RETURN TRUE;
END;
$$;

-- Function to update virtual positions with current market prices
CREATE OR REPLACE FUNCTION update_virtual_positions(
  p_symbol VARCHAR,
  p_current_price DECIMAL
) 
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Update all positions for the symbol
  UPDATE public.virtual_positions
  SET 
    current_price = p_current_price,
    market_value = qty * p_current_price,
    unrealized_pl = (p_current_price - avg_entry_price) * qty,
    unrealized_plpc = (p_current_price / NULLIF(avg_entry_price, 0)) - 1,
    updated_at = NOW()
  WHERE symbol = p_symbol;
  
  RETURN TRUE;
END;
$$;

-- Function to get user's current portfolio value
CREATE OR REPLACE FUNCTION get_user_portfolio_value(
  p_user_id UUID
) 
RETURNS DECIMAL
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_cash_balance DECIMAL;
  v_positions_value DECIMAL;
  v_total_value DECIMAL;
BEGIN
  -- Get the user's cash balance
  SELECT current_balance INTO v_cash_balance
  FROM public.virtual_trading_accounts
  WHERE user_id = p_user_id;
  
  -- Get the total value of all positions
  SELECT COALESCE(SUM(market_value), 0) INTO v_positions_value
  FROM public.virtual_positions
  WHERE user_id = p_user_id;
  
  -- Calculate total portfolio value
  v_total_value := COALESCE(v_cash_balance, 0) + COALESCE(v_positions_value, 0);
  
  RETURN v_total_value;
END;
$$;

-- =============================================
-- PART 4: TRIGGERS FOR AUTOMATION
-- =============================================

-- Trigger function to update the updated_at timestamp
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers on all tables
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 
    FROM pg_trigger 
    WHERE tgname = 'set_timestamp_virtual_accounts' 
      AND tgrelid = 'public.virtual_trading_accounts'::regclass
  ) THEN
    CREATE TRIGGER set_timestamp_virtual_accounts
    BEFORE UPDATE ON public.virtual_trading_accounts
    FOR EACH ROW
    EXECUTE FUNCTION trigger_set_timestamp();
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 
    FROM pg_trigger 
    WHERE tgname = 'set_timestamp_virtual_positions' 
      AND tgrelid = 'public.virtual_positions'::regclass
  ) THEN
    CREATE TRIGGER set_timestamp_virtual_positions
    BEFORE UPDATE ON public.virtual_positions
    FOR EACH ROW
    EXECUTE FUNCTION trigger_set_timestamp();
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 
    FROM pg_trigger 
    WHERE tgname = 'set_timestamp_virtual_orders' 
      AND tgrelid = 'public.virtual_orders'::regclass
  ) THEN
    CREATE TRIGGER set_timestamp_virtual_orders
    BEFORE UPDATE ON public.virtual_orders
    FOR EACH ROW
    EXECUTE FUNCTION trigger_set_timestamp();
  END IF;
END $$;

-- =============================================
-- PART 5: PERMISSIONS
-- =============================================

-- Grant appropriate permissions to authenticated users
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT SELECT ON public.virtual_trading_accounts TO authenticated;
GRANT SELECT ON public.virtual_positions TO authenticated;
GRANT SELECT ON public.virtual_orders TO authenticated;
GRANT SELECT ON public.virtual_transactions TO authenticated;

-- Grant all permissions to service_role (for server-side operations)
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO service_role;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO service_role;

-- =============================================
-- PART 6: INITIALIZATION
-- =============================================

-- You can add initial setup logic here, like inserting default data
-- or performing one-time configuration tasks

-- Example: Add a note to the end of the setup
DO $$
BEGIN
  RAISE NOTICE 'Virtual Trading accounts setup completed successfully!';
  RAISE NOTICE 'The application is now configured to:';
  RAISE NOTICE '1. Allow users to create virtual trading accounts with $10,000 starting balance';
  RAISE NOTICE '2. Track user positions, orders, and transactions';
  RAISE NOTICE '3. Execute trades on a single master Alpaca account';
END $$; 